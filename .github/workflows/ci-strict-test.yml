# .github/workflows/ci-strict-test.yml
name: CI Strict Mode Test (Non-Blocking)

on:
  push:
    branches: ['**']
  pull_request:
    branches: [develop, main]
  workflow_dispatch:

env:
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

# This prevents multiple runs of the test workflow
concurrency:
  group: ci-test-${{ github.ref }}
  cancel-in-progress: true

jobs:
  #1: Strict Linting and Formatting Checks
  strict-lint-format:
    name: "Strict Lint/Format Check"
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [frontend, backend, realtime, auth-service]
      fail-fast: false  # Continue checking all services even if one fails
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      
      - name: Check service structure
        id: service-check
        working-directory: ${{ matrix.service }}
        run: |
          echo "================== ${{ matrix.service }} =================="
          
          if [ ! -f "package.json" ]; then
            echo "FAIL: No package.json found"
            echo "has_package=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "package.json exists"
          echo "has_package=true" >> $GITHUB_OUTPUT
      
      - name: Cache dependencies
        if: steps.service-check.outputs.has_package == 'true'
        uses: actions/cache@v3
        with:
          path: ${{ matrix.service }}/node_modules
          key: ${{ runner.os }}-${{ matrix.service }}-${{ hashFiles(format('{0}/package-lock.json', matrix.service)) }}
      
      - name: Install dependencies
        if: steps.service-check.outputs.has_package == 'true'
        working-directory: ${{ matrix.service }}
        run: |
          echo "Installing dependencies..."
          npm install
      
      - name: Check ESLint configuration
        if: steps.service-check.outputs.has_package == 'true'
        working-directory: ${{ matrix.service }}
        run: |
          echo "Checking ESLint..."
          
          # Check if lint script exists
          if ! npm run | grep -q "lint"; then
            echo "FAIL: No 'lint' script in package.json"
            echo "Add to package.json scripts:"
            echo '  "lint": "eslint . --ext .ts,.tsx"'
            exit 1
          fi
          
          # Check if ESLint is installed
          if ! npm ls eslint > /dev/null 2>&1; then
            echo "FAIL: ESLint not installed"
            echo "Run: npm install --save-dev eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin"
            exit 1
          fi
          
          # Check if .eslintrc exists
          if [ ! -f ".eslintrc.json" ] && [ ! -f ".eslintrc.js" ] && [ ! -f ".eslintrc" ]; then
            echo "WARNING: No ESLint config file found"
          fi
          
          # Run ESLint
          echo "Running ESLint..."
          npm run lint || {
            echo "FAIL: ESLint found issues"
            exit 1
          }
          
          echo "ESLint passed"
      
      - name: Check Prettier configuration
        if: steps.service-check.outputs.has_package == 'true'
        working-directory: ${{ matrix.service }}
        run: |
          echo "Checking Prettier..."
          
          # Check if format:check script exists
          if ! npm run | grep -q "format:check"; then
            echo "FAIL: No 'format:check' script in package.json"
            echo "Add to package.json scripts:"
            echo '  "format:check": "prettier --check ."'
            echo '  "format": "prettier --write ."'
            exit 1
          fi
          
          # Check if Prettier is installed
          if ! npm ls prettier > /dev/null 2>&1; then
            echo "FAIL: Prettier not installed"
            echo "Run: npm install --save-dev prettier"
            exit 1
          fi
          
          # Run Prettier check
          echo "Running Prettier check..."
          npm run format:check || {
            echo "FAIL: Code is not formatted"
            echo "Run 'npm run format' to fix"
            exit 1
          }
          
          echo "Prettier check passed"

  #2: Strict TypeScript Compilation
  strict-typescript:
    name: "Strict TypeScript Check"
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [frontend, backend, realtime, auth-service]
      fail-fast: false
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      
      - name: TypeScript validation
        working-directory: ${{ matrix.service }}
        run: |
          echo "================== ${{ matrix.service }} TypeScript =================="
          
          # Check package.json
          if [ ! -f "package.json" ]; then
            echo "FAIL: No package.json found"
            exit 1
          fi
          
          # Install dependencies
          npm install
          
          # Check TypeScript is installed
          if ! npm ls typescript > /dev/null 2>&1; then
            echo "FAIL: TypeScript not installed"
            echo "Run: npm install --save-dev typescript @types/node"
            exit 1
          fi
          
          # Check tsconfig.json exists
          if [ ! -f "tsconfig.json" ]; then
            echo "FAIL: No tsconfig.json found"
            echo "Run: npx tsc --init"
            exit 1
          fi
          
          # Check for .ts or .tsx files
          if ! find . -name "*.ts" -o -name "*.tsx" | grep -q .; then
            echo "WARNING: No TypeScript files found"
            echo "Project should be using TypeScript as per requirements"
          fi
          
          # Compile TypeScript
          echo "Compiling TypeScript..."
          npx tsc --noEmit || {
            echo "FAIL: TypeScript compilation errors"
            exit 1
          }
          
          echo "TypeScript compilation successful"

  #3: Strict Docker & Service Health
  strict-build-verify:
    name: "Strict Build & Health Checks"
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Validate docker-compose.yml
        run: |
          echo "Validating Docker Compose configuration..."
          docker-compose config > /dev/null || {
            echo "FAIL: Invalid docker-compose.yml"
            exit 1
          }
          echo "docker-compose.yml is valid"
      
      - name: Create SSL certificates
        run: |
          echo "Creating SSL certificates..."
          mkdir -p nginx/ssl
          openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
            -keyout nginx/ssl/nginx.key \
            -out nginx/ssl/nginx.crt \
            -subj "/C=US/ST=State/L=City/O=42School/CN=localhost"
      
      - name: Check nginx configuration exists
        run: |
          if [ ! -f "nginx/nginx.conf" ]; then
            echo "FAIL: nginx/nginx.conf not found"
            echo "HTTPS/WSS is mandatory for the project"
            exit 1
          fi
          echo "nginx.conf exists"
      
      - name: Build all services
        run: |
          echo "Building all Docker services..."
          docker-compose build --parallel || {
            echo "FAIL: Docker build failed"
            exit 1
          }
          echo "All services built successfully"
      
      - name: Start services
        run: |
          echo "Starting services..."
          docker-compose up -d
          
          echo "Waiting 20 seconds for services to initialize..."
          sleep 20
          
          docker-compose ps
      
      - name: Verify all containers are running
        run: |
          echo "Checking container status..."
          
          EXPECTED_CONTAINERS=(
            "ft_transcendence_nginx"
            "ft_transcendence_frontend"
            "ft_transcendence_backend"
            "ft_transcendence_realtime"
            "ft_transcendence_auth"
          )
          
          FAILED=0
          for container in "${EXPECTED_CONTAINERS[@]}"; do
            if docker ps --format "{{.Names}}" | grep -q "^${container}$"; then
              echo "$container is running"
            else
              echo "FAIL: $container is not running"
              echo "Logs for $container:"
              docker logs "$container" 2>&1 | tail -20
              FAILED=1
            fi
          done
          
          if [ $FAILED -eq 1 ]; then
            exit 1
          fi
      
      - name: Strict health checks
        run: |
          echo "Running strict health checks..."
          
          # Frontend must be accessible
          echo -n "Frontend (3000): "
          curl -f -s -o /dev/null http://localhost:3000 || {
            echo "FAIL"
            docker logs ft_transcendence_frontend | tail -20
            exit 1
          }
          echo "OK"
          
          # Backend MUST have health endpoint
          echo -n "Backend Health Endpoint (8080): "
          curl -f -s http://localhost:8080/api/health || {
            echo "FAIL: /api/health endpoint is required"
            echo "Backend must implement: GET /api/health returning 200 OK"
            docker logs ft_transcendence_backend | tail -20
            exit 1
          }
          echo "OK"
          
          # Auth service MUST have health endpoint
          echo -n "Auth Service Health Endpoint (8082): "
          curl -f -s http://localhost:8082/api/auth/health || {
            echo "FAIL: /api/auth/health endpoint is required"
            echo "Auth service must implement: GET /api/auth/health returning 200 OK"
            docker logs ft_transcendence_auth | tail -20
            exit 1
          }
          echo "OK"
          
          # Realtime service must at least have port open
          echo -n "Realtime Service (8081): "
          nc -zv localhost 8081 || {
            echo "FAIL: Port 8081 not accessible"
            docker logs ft_transcendence_realtime | tail -20
            exit 1
          }
          echo "OK"
      
      - name: HTTPS/WSS Requirements
        run: |
          echo "Checking HTTPS/WSS (Mandatory)..."
          
          # Nginx config must be valid
          docker-compose exec -T nginx nginx -t || {
            echo "FAIL: Invalid nginx configuration"
            exit 1
          }
          
          # HTTPS must work
          echo -n "HTTPS (443): "
          curl -k -f -s https://localhost > /dev/null || {
            echo "FAIL: HTTPS is mandatory"
            docker logs ft_transcendence_nginx | tail -20
            exit 1
          }
          echo "Working"
          
          # HTTP should redirect to HTTPS
          echo -n "HTTPâ†’HTTPS Redirect: "
          REDIRECT=$(curl -s -o /dev/null -w "%{http_code}" -L http://localhost)
          if [[ "$REDIRECT" == "301" ]] || [[ "$REDIRECT" == "302" ]]; then
            echo "Configured"
          else
            echo "WARNING: HTTP to HTTPS redirect not configured (recommended)"
          fi
      
      - name: Cleanup
        if: always()
        run: |
          docker-compose down -v
          docker-compose rm -f

  #4: Integration Tests Through Nginx
  strict-integration:
    name: "Strict Integration Tests"
    runs-on: ubuntu-latest
    needs: [strict-build-verify]
    steps:
      - uses: actions/checkout@v3
      
      - name: Create SSL certificates
        run: |
          mkdir -p nginx/ssl
          openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
            -keyout nginx/ssl/nginx.key \
            -out nginx/ssl/nginx.crt \
            -subj "/C=US/ST=State/L=City/O=42School/CN=localhost"
      
      - name: Make wait-for-it.sh executable
        run: |
          if [ -f "./scripts/wait-for-it.sh" ]; then
            chmod +x ./scripts/wait-for-it.sh
          else
            echo "FAIL: scripts/wait-for-it.sh not found"
            exit 1
          fi
      
      - name: Start services
        run: |
          docker-compose up -d
          docker-compose ps
      
      - name: Wait for all services
        run: |
          echo "Waiting for services..."
          
          ./scripts/wait-for-it.sh localhost:8080 -t 60 || {
            echo "Backend failed to start"
            docker logs ft_transcendence_backend
            exit 1
          }
          
          ./scripts/wait-for-it.sh localhost:3000 -t 60 || {
            echo "Frontend failed to start"
            docker logs ft_transcendence_frontend
            exit 1
          }
          
          ./scripts/wait-for-it.sh localhost:8082 -t 60 || {
            echo "Auth service failed to start"
            docker logs ft_transcendence_auth
            exit 1
          }
          
          ./scripts/wait-for-it.sh localhost:443 -t 60 || {
            echo "Nginx failed to start"
            docker logs ft_transcendence_nginx
            exit 1
          }
          
          sleep 10
      
      - name: Test nginx routing (STRICT)
        run: |
          echo "Testing nginx routing requirements..."
          
          # Frontend MUST be accessible through HTTPS
          echo "Testing frontend through nginx:"
          curl -k -f -s -o /dev/null https://localhost/ || {
            echo "FAIL: Frontend not accessible through nginx HTTPS"
            docker logs ft_transcendence_nginx | tail -30
            exit 1
          }
          echo "Frontend accessible"
          
          # Backend API MUST be accessible through nginx
          echo "Testing backend API through nginx:"
          curl -k -f -s https://localhost/api/health || {
            echo "FAIL: Backend API not routed through nginx"
            echo "Nginx must proxy /api/* to backend:8080"
            docker logs ft_transcendence_nginx | tail -30
            exit 1
          }
          echo "Backend API accessible"
          
          # Auth service MUST be accessible through nginx
          echo "Testing auth service through nginx:"
          curl -k -f -s https://localhost/auth/health || {
            echo "FAIL: Auth service not routed through nginx"
            echo "Nginx must proxy /auth/* to auth-service:8082"
            docker logs ft_transcendence_nginx | tail -30
            exit 1
          }
          echo "Auth service accessible"
          
          # WebSocket endpoint SHOULD be configured
          echo "Testing WebSocket routing:"
          RESPONSE=$(curl -k -s -o /dev/null -w "%{http_code}" https://localhost/ws/ \
            -H "Upgrade: websocket" \
            -H "Connection: Upgrade" \
            -H "Sec-WebSocket-Version: 13" \
            -H "Sec-WebSocket-Key: test")
          
          if [[ "$RESPONSE" == "101" ]] || [[ "$RESPONSE" == "426" ]]; then
            echo "WebSocket endpoint configured"
          else
            echo "WARNING: WebSocket not properly configured (got HTTP $RESPONSE)"
            echo "Should return 101 (Switching Protocols) or 426 (Upgrade Required)"
          fi
      
      - name: Test single command deployment
        run: |
          echo "Testing single command deployment requirement..."
          
          # Stop everything
          docker-compose down -v
          
          # Must be able to start with single command
          docker-compose up -d || {
            echo "FAIL: Single command deployment failed"
            echo "Project must start with just 'docker-compose up -d'"
            exit 1
          }
          
          # Wait and verify
          sleep 20
          
          # Check if accessible
          curl -k -f -s -o /dev/null https://localhost/ || {
            echo "FAIL: Service not accessible after single command deployment"
            exit 1
          }
          
          echo "Single command deployment works"
      
      - name: Cleanup
        if: always()
        run: |
          docker-compose down -v
          docker-compose rm -f

  # Final Report (Always Runs)
  test-report:
    name: "Strict Mode Report"
    runs-on: ubuntu-latest
    needs: [strict-lint-format, strict-typescript, strict-build-verify, strict-integration]
    if: always()
    steps:
      - name: Generate Report
        run: |
          echo "# STRICT CI TEST REPORT"
          echo ""
          echo "This workflow tests strict CI requirements but DOES NOT block merges."
          echo ""
          echo "## Results:"
          echo ""
          
          # Function to convert result to emoji
          result_emoji() {
            if [ "$1" == "success" ]; then echo "[PASS]"
            elif [ "$1" == "failure" ]; then echo "[FAIL]"
            elif [ "$1" == "skipped" ]; then echo "[SKIP]"
            else echo "[WARN]"
            fi
          }
          
          echo "| Check | Status | Required |"
          echo "|-------|--------|----------|"
          echo "| Lint & Format | $(result_emoji '${{ needs.strict-lint-format.result }}') ${{ needs.strict-lint-format.result }} | Yes |"
          echo "| TypeScript | $(result_emoji '${{ needs.strict-typescript.result }}') ${{ needs.strict-typescript.result }} | Yes |"
          echo "| Docker Build | $(result_emoji '${{ needs.strict-build-verify.result }}') ${{ needs.strict-build-verify.result }} | Yes |"
          echo "| Integration | $(result_emoji '${{ needs.strict-integration.result }}') ${{ needs.strict-integration.result }} | Yes |"
          echo ""
          
          # Overall status
          if [ "${{ needs.strict-build-verify.result }}" == "success" ] && \
             [ "${{ needs.strict-integration.result }}" == "success" ]; then
            echo "## Core Requirements Met"
            echo "The project meets minimum deployment requirements."
          else
            echo "## Core Requirements Not Met"
            echo "The project has issues that would prevent deployment in strict mode."
          fi
          
          echo ""
          echo "## Required Actions:"
          echo ""
          
          if [ "${{ needs.strict-lint-format.result }}" != "success" ]; then
            echo "### Linting/Formatting Issues:"
            echo "- Add 'lint' and 'format:check' scripts to package.json"
            echo "- Install ESLint and Prettier"
            echo "- Fix any linting errors"
            echo ""
          fi
          
          if [ "${{ needs.strict-typescript.result }}" != "success" ]; then
            echo "### TypeScript Issues:"
            echo "- Ensure TypeScript is installed"
            echo "- Create tsconfig.json"
            echo "- Fix compilation errors"
            echo ""
          fi
          
          if [ "${{ needs.strict-build-verify.result }}" != "success" ]; then
            echo "### Build/Health Issues:"
            echo "- Implement /api/health endpoints"
            echo "- Fix Docker build errors"
            echo "- Ensure HTTPS is working"
            echo ""
          fi
          
          echo "---"
          echo "*This is a test workflow. It shows what would fail in strict mode but does not block PR merges.*"
      
      - name: Comment on PR (if applicable)
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v6
        continue-on-error: true
        with:
          script: |
            const emoji = (result) => {
              return result === 'success' ? '[PASS]' : result === 'failure' ? '[FAIL]' : '[WARN]';
            };
            
            const body = `## Strict CI Test Results (Non-Blocking)
            
            | Check | Status |
            |-------|--------|
            | Lint & Format | ${emoji('${{ needs.strict-lint-format.result }}')} ${{ needs.strict-lint-format.result }} |
            | TypeScript | ${emoji('${{ needs.strict-typescript.result }}')} ${{ needs.strict-typescript.result }} |
            | Build & Health | ${emoji('${{ needs.strict-build-verify.result }}')} ${{ needs.strict-build-verify.result }} |
            | Integration | ${emoji('${{ needs.strict-integration.result }}')} ${{ needs.strict-integration.result }} |
            
            *This test shows what would happen with strict CI enabled. It does not block merging.*
            
            [View Full Test Run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });